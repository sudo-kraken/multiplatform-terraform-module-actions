# Name of the workflow
name: Init AWS VPC CD
# Define the events that trigger the workflow
on:
  # Trigger the workflow manually from the Actions tab
  workflow_dispatch:
    # It requires several inputs provided by the user
    inputs:
      # These inputs are details for the vSphere environment, deployment parameters, and vSphere object information
      vpc_name:
        description: 'Enter the name to give the VPC ( lowercase )'
        required: true  
      is_eks_enabled:
        description: 'Is this VPC going to be used to run EKS'
        required: true
        default: false
        type: choice
        options:
        - 'true'
        - 'false'    
      vpc_subnet:
        description: 'Enter subnet cidr i.e. "10.10.0.0/16"'
        required: true
      vpc_priv_subnets:
        description: 'Enter 3 private subnet cidrs, comma seperated i.e. "10.10.1.0/24,10.10.2.0/24,10.10.3.0/24"'
        required: true
      vpc_pub_subnets:
        description: 'Enter 3 public subnet cidrs, comma seperated i.e. "10.10.10.0/24,10.10.11.0/24,10.10.12.0/24"'
        required: true     
      client_tag:
        description: 'Enter client tag value ( lowercase ) i.e. "client1" or "shared"'
        required: true  
      environment_tag:
        description: 'Enter environment tag value ( lowercase ) i.e. "prod" or "dev"'
        required: true          

# Define permissions for this workflow
permissions:
  # Only read access to the contents is needed
  contents: read

# Define jobs in this workflow  
jobs:
  # Define a job for Terraform actions
  generate-main-tf:
    # Name of the job  
    name: 'Terraform AWS VPC main.tf Generation'
    # Define the type of runner that the job will run on
    runs-on: [self-hosted, devops]
    # Define the environment in which the job will run
    environment: production

    # Define steps for this job
    steps:
      # Checkout the repository to the GitHub Actions runner 
      - name: Checkout
        uses: actions/checkout@v3    
            
      # If main.tf does not exist, we generate a new one using user input
      - name: Check if main.tf exists
        run: |
          if [ -f "main.tf" ]; then
            echo "main.tf already exists, skipping file generation."
            echo "file_exists=true" >> $GITHUB_OUTPUT
          else
            echo "main.tf does not exist, continuing with file generation."
            echo "file_exists=false" >> $GITHUB_OUTPUT
          fi
        id: check-main-tf
      
      - name: Generate main.tf with user input
        if: steps.check-main-tf.outputs.file_exists == 'false'
        run: |
          cat > main.tf << EOF
          # Define the required version of Terraform and the required AWS provider version
          terraform {
            required_version = ">= 1.5.0"

            backend "s3" {}
            
            required_providers {
              aws = {
                source  = "hashicorp/aws"
                version = "~> 5.0"
              }
              
            }
            
          }

          # Configure the AWS Provider          
          provider "aws" {
            region = "eu-west-2"
          }
          
          module "new_vpc" {
            source = "./modules/aws-vpc"
          
            region = "eu-west-2"
          
            vpc_name = "<vpc_name>"
            is_eks_enabled = <is_eks_enabled>
            vpc_cidr = "<vpc_subnet>"
            public_subnet_cidrs = ["<pub_sub_1>", "<pub_sub_2>", "<pub_sub_3>"]
            private_subnet_cidrs = ["<priv_sub_1>", "<priv_sub_2>", "<priv_sub_3>"]
            availability_zones = ["eu-west-2a", "eu-west-2b", "eu-west-2c"]
            client_tag = "<client_tag>"
            environment_tag = "<environment_tag>"
          }
          EOF

          # Replace the placeholders with the actual input values
          sed -i "s|<vpc_name>|${{ github.event.inputs.vpc_name }}|g" main.tf
          sed -i "s|<is_eks_enabled>|${{ github.event.inputs.is_eks_enabled }}|g" main.tf
          sed -i "s|<vpc_subnet>|${{ github.event.inputs.vpc_subnet }}|g" main.tf

          IFS=',' read -ra VPC_PRIV_SUBNETS <<< "${{ github.event.inputs.vpc_priv_subnets }}"
          sed -i "s|<priv_sub_1>|${VPC_PRIV_SUBNETS[0]}|g" main.tf
          sed -i "s|<priv_sub_2>|${VPC_PRIV_SUBNETS[1]}|g" main.tf
          sed -i "s|<priv_sub_3>|${VPC_PRIV_SUBNETS[2]}|g" main.tf
          
          IFS=',' read -ra VPC_PUB_SUBNETS <<< "${{ github.event.inputs.vpc_pub_subnets }}"          
          sed -i "s|<pub_sub_1>|${VPC_PUB_SUBNETS[0]}|g" main.tf
          sed -i "s|<pub_sub_2>|${VPC_PUB_SUBNETS[1]}|g" main.tf
          sed -i "s|<pub_sub_3>|${VPC_PUB_SUBNETS[2]}|g" main.tf

          sed -i "s|<client_tag>|${{ github.event.inputs.client_tag }}|g" main.tf
          sed -i "s|<environment_tag>|${{ github.event.inputs.environment_tag }}|g" main.tf

          # Print the generated main.tf
          cat main.tf

      # If a new main.tf file was created, commit and push it to the repository
      - name: Commit and push main.tf
        if: steps.check-main-tf.outputs.file_exists == 'false'
        run: |
          git config --global user.name "GitHub Actions"
          git config --global user.email "github-actions@users.noreply.github.com"
          git add main.tf
          git commit -m "Add generated main.tf"
          git push